BASIC GITHUB STUFF:
git add [filename]
git commit -m '[commit info]'
git push github master

	[the "master" is optional, it specifies which local branch to push to github]



EXTRA HELP:
Git Community Book
http://cheat.errtheblog.com/s/git/
man gittutorial
man gittutorial-2
git cheat sheet:   http://ktown.kde.org/~zrusin/git/git-cheat-sheet.svg




GUI Programs:
gitk
gitk -all
qgit4
git-gui or git gui



BASIC GIT STUFF:


========ORGANIZE THIS SECTION============
git log -n3
git log --stat --summary


git diff HEAD^..HEAD
To view the last changes you made


Haven't committed yet, but don't want to save the changes? You can throw them away:
git reset --hard



Messed up the commit message? This will let you re-enter it:
git commit --amend



Forgot something in your last commit? That's easy to fix.
    git reset --soft HEAD^
    Add that stuff you forgot:
    git add forgot.txt these.txt
    Then write over the last commit:
    git commit




Getting in the habit of creating quality commit messages makes using and collaborating with Git a lot easier. As a general rule, your messages should start with a single line that's no more than about 50 characters and that describes the changeset concisely, followed by a blank line, followed by a more detailed explanation.


===========ORGANIZE THE ABOVE SECTION============



git add  =  does BOTH adding files to the scope of the project (they are now tracked) AND adding changes to the files to the staging area

>If Git already has the file in the repository, then git-add makes it seem like git has Alzheimer's and you have to introduce it to the same new person twice.  Actually, what git add does is to move the current version of the named file to a special staging area, holding files that are ready to be committed.  The GitHub blog reports that git add may soon take on the new name git-stage, to reflect this.


git add .  = add, recursively, all files

git add *  or   git add *.txt  =  Fileglobs (e.g. *.c) can be given to add all matching files.

git rm --cached  = does not remove the file from the working dir, but removes them from scope of the project (not tracked anymore) and they will be deleted from the git repo upon next commit.  Commits absence-of-file from the project.   git-show will display that it will be deleted from repo upon next commmit.   Is not used for unstaging a file, but rather it stages a file-deletion commit.


git rm   =  removes the file in the working dir, removes them from the scope of the project (they are untracked -- well, actually they can't be tracked because they don't exist anymore), and they will be deleted from the repo upon the next commit.

git add -u  = Tell git to remove files that are deleted in file system but not yet removed from index (instead of git rm on all of them)


git log -- show complete log of all past commits, giving the commit SHA-1,
author, date, and summary line

git log -p  -- same as the above, but include the diff 


git log [filename] OR git log -p [filename]  --  do show the history/log of
commits that include the filename given

git whatchanged -p [filename] 

git status / show files added to the staging area, files with changes, and untracked files



HEAD = the current tip of the current branch, the last (most recent) commit of the branch.
	specified in the .git/HEAD file
	the HEAD file should specify a commit/tree to point to, like:  "41d5b7e362c33dc54cbc814e50403a2084204f9f"


git show HEAD = show the tip of the current branch, including the SHA-1 of its commit (which is the same commit as listed in the .git/HEAD file mentioned above)

git show HEAD^ = show the parent of HEAD   (in zsh, you may need to use a backslash to escape the carrot)

git show HEAD^^ = show the grandparent of HEAD   (in zsh, you may need to use a backslash to escape the carrot)

git show HEAD~4 = show the great-great-grandparent of HEAD   (in zsh, you may need to use a backslash to escape the carrot)

git show [SHA-1]  =  show info on the commit specified by the SHA-1


git show [branch]  = show tip of the specified branch



git commit -a
  commit all files modified since your last commit
  (does not include new (untracked) files)

Information about "commit messages":
>The blank line separating the summary from the body is critical (unless you
omit the body entirely); tools like rebase can get confused if you run the two
together.

> All git porcelain commands that work with patches in emails assume that a blank line separates subject from body

>Write your commit message in the present tense: "Fix bug" and not "Fixed bug."
This convention matches up with commit messages generated by commands like git
merge and git revert, and with the norms of other major opensource projects.

> Commits should be something that someone might want to patch or revert in its entirety, and never piecewise. If it could be useful in pieces, make separate commits. This will result in short, clear, and concise commit messages.


git commit -v   --   Show unified diff between the HEAD commit and what would be committed at the bottom of the commit message template.

git commit --amend
  edit the commit message of the most recent commit

git commit --amend <file1> <file2> ...
  Redo previous commit, including changes made to <file1>, <file2>, etc...
  The commit you create replaces the current tip.
  This is helpful is you make a change to a file, then update that change, and
  then want to commit the updated change.  Rather than two commits towards one
  goal, just use one commit instead so that nobody has to read your progress
  on some small issue.



git diff   /     show a diff of the changes made in working directory that are not staged for commit  (the dif b/t working directory and index)
	git diff -- <filename>    /    to diff one file

git diff --cached    /   to show a diff between staging area and HEAD  (difference between index and last commit)

git diff HEAD  /   shows changes in working directory since last commit  (what would be commit if you run "git commit -a")



git whatchanged
	-p	Show text content of diffs, instead of just git's internal diff output format (which  is useful only to tell the changed paths and their nature of changes.


git log    /    show history of recent commits, most recent on top. Useful options:
  --color       with color
  --graph       with an ASCII-art commit graph on the left
  --decorate    with branch and tag names on appropriate commits
  --stat        with stats (files changed, insertions, and deletions)
  -p            with full diffs


git log v2.5    = show commits since (not reachable from) tag of "v2.5"

git log [file]  =  show commits that modify [file]


git tag [title] [SHA1-1]  = create a "lightweight tag" which points to a certain commit (specified by its SHA-1).  Cannot be signed.

git tag -a (or -s) -m "[msg]"  [tagname]  [SHA-1]   = create a tag object, which can be signed


git branch [new-branch-name]   =  create new branch from master branch

git branch = list branches

git checkout [name-of-branch]  = checkout [name-of-branch] into working directory
git checkout -- [name of file]   = add or replace [file] from repo into working directory
git checkout [SHA-1]  = Examine an earlier version of your source
git checkout [SHA-1 of tree-ish: a tree, commit, or tag] [name of file]  = checkout file from certain tree
	[good to do "git log [filename]" first to find out which tree]

git merge [branch] = merge [branch] into your master branch

git branch -d [branch]   = delete branch, ensuring all differences have been merged
git branch -D [branch]   = delete branch, no matter whether all differences have been merged


git reset = Sets the current head to the specified commit and optionally resets the index and working tree to match. This command is useful if you notice some small error in a recent commit (or set of commits) and want to redo that part without showing the undo in the history.  (If you want to undo a commit other than the latest on a branch, git-revert is your friend.)

       --mixed
           Resets the index but not the working tree (i.e., the changed files
           are preserved but not marked for commit) and reports what has not
           been updated. This is the default action.

       --soft
           Does not touch the index file nor the working tree at all, but
           requires them to be in a good order. This leaves all your changed
           files "Changes to be committed", as git-status would put it.

       --hard
           Matches the working tree and index to that of the tree being
           switched to. Any changes to tracked files in the working tree since
           <commit> are lost.

       --merge
           Resets the index to match the tree recorded by the named commit,
           and updates the files that are different between the named commit
           and the current commit in the working tree.


git reset = reset index to HEAD (and not the working tree)  --  recommended for when copying another person's repo, to make sure there are no staged-but-uncommmitted files.

git reset HEAD <file>  =  to unstage file from index
git reset HEAD  = unstage all files from index
git reset --hard HEAD^  = reset both repo branch and current working directory to the parent of HEAD  (lose changes in working directory and the later commits of the branch)

git reset --hard HEAD~3  = The last three commits (HEAD, HEAD^, and HEAD~2) were bad and            you do not want to ever see them again. Do not do this if you have already given these commits to somebody else. 


git pull = does both "fetch" and "merge"


git repo is technically both the working dir and the .git dir, though often the repo's are distributed w/a blank working dir, a blank index, and just the .git directory


rsync -rL rsync://rsync.kernel.org/pub/scm/git.git .git
	...is the same idea as...
git clone rsync://rsync.kernel.org/pub/scm/git/git.git/ my-git-test

	(both require a "git checkout" after cd'ing into the new directory)
	(-rL = recursive & preserve links)
	(when using rsync, the HEAD is messed up.  Another person had the same trouble: http://lists.zerezo.com/git/msg675736.html)

This server is also setup for this to work:
	it clone git://git.kernel.org/pub/scm/git/git.git/ my-git-test





ORIGINAL INSTRUCTIONS FOR GITHUB (the items below come from the GitHub repo-creation page):



Global setup:

  Download and install Git
  git config --global user.name "Your Name"
  git config --global user.email write2david@gmail.com
  Add your public key
        


Example steps:

  mkdir screendoor
  cd screendoor
  git init
  touch README
  git add README
  git commit -m 'first commit'
  git remote add origin git@github.com:write2david/screendoor.git
  git push origin master
