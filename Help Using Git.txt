HELP USING GIT


======OTHER RESOURCES======

Git Community Book:
	http://book.git-scm.com/

Git User Manual:
	http://www.kernel.org/pub/software/scm/git/docs/user-manual.html

Git Cheat Sheets:
	http://cheat.errtheblog.com/s/git/
	http://ktown.kde.org/~zrusin/git/git-cheat-sheet.svg
	www-cs-students.stanford.edu/~blynn/gitmagic/book.pdf

Man Pages:
	gittutorial
	gittutorial-2

Revision Control Systems, Distributed vs. Centralized:
	http://en.wikipedia.org/wiki/Distributed_revision_control
	http://git.wiki.kernel.org/index.php/GitSvnComparison
	http://hginit.com/00.html

Quality Tutorials:
	http://utsl.gen.nz/talks/git-svn/intro.html
	http://ftp.newartisans.com/pub/git.from.bottom.up.pdf

Wide Variety of Documentation:
	https://git.wiki.kernel.org/index.php/GitDocumentation
	gitref.org
	progit.org


======GUI PROGRAMS=======
gitk or ('gitk --all')
qgit4
git-gui (or 'git gui')
giggle

Large list of GUI programs:
https://git.wiki.kernel.org/index.php/InterfacesFrontendsAndTools#Graphical_Interfaces


=====GIT CONFIGURATION======

git config --global user.name "Your Name"
git config --global user.email write2david@gmail.com

Add color to output:
	git config --global color.status auto
	git config --global color.diff auto	
	git config --global color.branch auto
	



====TERMINOLOGY====

HEAD = the current tip of the current branch. A "tip" is the the last (most recent) commit/revision of the branch.
	It is pecified in the .git/HEAD file.
	The HEAD file should specify a commit/tree to point to, like:  "41d5b7e362c33dc54cbc814e50403a2084204f9f"


Tree-ish = 
SHA-1 = 
Commit = Revision
	--Links to a parent commit and a tree, each of which is ID'd by its SHA-1



======BASIC GIT COMMANDS======



==ADDING==

git add  =  does BOTH adding files to the scope of the project (they are now tracked) AND adding changes to the files to the staging area

>If Git already has the file in the repository, then git-add makes it seem like git has Alzheimer's and you have to introduce it to the same new person twice.  Actually, what git add does is to move the current version of the named file to a special staging area, holding files that are ready to be committed.  The GitHub blog reports that git add may soon take on the new name git-stage, to reflect this.


git add .  = add, recursively, all files

git add *  or   git add *.txt  =  Fileglobs (e.g. *.c) can be given to add all matching files.


git add -u  = Update only files that git already knows about, staging modified content for commit and marking deleted files for removal.  So, this includes telling git to remove files that are deleted in file system but not yet removed from index (instead of git rm on them).



==REMOVING==

git rm   =  removes the file in the working dir, removes them from the scope of the project (they are untracked -- well, actually they can't be tracked because they don't exist anymore), and they will be deleted from the repo upon the next commit.

git rm --cached  = does not remove the file from the working dir, but removes them from scope of the project (not tracked anymore) and they will be deleted from the git repo upon next commit.  Commits absence-of-file from the project.   git-show will display that it will be deleted from repo upon next commmit.   Is not used for unstaging a file, but rather it stages a file-deletion commit.




==STATUS==

git status / show files added to the staging area, files with changes, and untracked files



==COMMIT==

git commit -a
  commit all files modified since your last commit
  (does not include new (untracked) files)

Information about "commit messages":
>The blank line separating the summary from the body is critical (unless you
omit the body entirely); tools like rebase can get confused if you run the two
together.

> All git porcelain commands that work with patches in emails assume that a blank line separates subject from body

>Write your commit message in the present tense: "Fix bug" and not "Fixed bug."
This convention matches up with commit messages generated by commands like git
merge and git revert, and with the norms of other major opensource projects.

> Commits should be something that someone might want to patch or revert in its entirety, and never piecewise. If it could be useful in pieces, make separate commits. This will result in short, clear, and concise commit messages.

Getting in the habit of creating quality commit messages makes using and
collaborating with Git a lot easier. As a general rule, your messages should
start with a single line that's no more than about 50 characters and that
describes the changeset concisely, followed by a blank line, followed by a
more detailed explanation.  If the more detailed explanation is multi-line,
wrap each line at about 722 characters.



git commit -v   --   Show unified diff between the HEAD commit and what would be committed at the bottom of the commit message template.

git commit --amend
  edit the commit message of the most recent commit

git commit --amend <file1> <file2> ...
  Redo previous commit (replacing the last commit with a new one), including changes made to <file1>, <file2>, etc...
  The commit you create replaces the current tip.
  This is helpful is you make a change to a file, then update that change, and
  then want to commit the updated change.  Rather than two commits towards one
  goal, just use one commit instead so that nobody has to read your progress
  on some small issue.


# Add to the index and commit cake.txt in one go.
git commit cake.txt


Messed up the commit message? This will let you re-enter it:
git commit --amend



==LOG==

Git log pipes through 'less' and generates output on the fly (as-needed), so you don't have to worry about the potential problem of loading a HUGH history into less.


git log -- show complete log of all past commits, giving the commit SHA-1,
author, date, and summary line

git log -p  -- same as the above, but include the diff 


git log [filename] OR git log -p [filename]  --  do show the history/log of
commits that include the filename given

git log -n3
git log --stat --summary


git whatchanged -p [filename] 


You can use "git log" to explore the range syntax just introduced. For example, to see a list of the most recent 3 revisions you can use "HEAD~3..", (the destination of the range is implicitly HEAD in this case):

$ git log HEAD~3..



git log v2.5    = show commits since (not reachable from) tag of "v2.5"

git log [file]  =  show commits that modify [file]



Another example with git log:
git log --since="2 weeks ago" --until="yesterday"


To prevent confusion with options and branch names, paths may need to be prefixed with "-- " to separate them from git options/arguments or SHA-1's.   Listing them after "--" which is necessary to distinguish commit names from file names, for example:

$ git log -- Makefile


git log    /    show history of recent commits, most recent on top. Useful options:
  --color       with color
  --graph       with an ASCII-art commit graph on the left
  --decorate    with branch and tag names on appropriate commits
  --stat        with stats (files changed, insertions, and deletions)
  -p            with full diffs




==SHOW==

git show HEAD = show the tip of the current branch, including the SHA-1 of its commit (which is the same commit as listed in the .git/HEAD file mentioned above)

git show HEAD^ = show the parent of HEAD   (in zsh, you may need to use a backslash to escape the carrot)

git show HEAD^^ = show the grandparent of HEAD   (in zsh, you may need to use a backslash to escape the carrot)

git show HEAD~4 = show the great-great-grandparent of HEAD   (in zsh, you may need to use a backslash to escape the carrot)

git show [SHA-1]  =  show info on the commit specified by the SHA-1

git show [branch]  = show tip (last commit) of the specified branch


You can see the contents of a file, the listing of a directory or a commit with  [rev = SHA-1]:

git show rev:path/to/file
git show rev:path/to/directory
git show rev



==DIFF==


git diff   /     show a diff of the changes made in working directory that are not staged for commit  (the dif b/t working directory and index)
	git diff -- <filename>    /    to diff one file

git diff --cached    /   to show a diff between staging area and HEAD  (difference between index and last commit)

git diff HEAD  /   shows changes in working directory since last commit  (what would be commit if you run "git commit -a")

git diff HEAD^..HEAD
	To view the last changes you made


git whatchanged
	-p	Show text content of diffs, instead of just git's internal diff output format (which  is useful only to tell the changed paths and their nature of changes.


Between a particular version and 2 versions ago:
$ git diff SHA1_HASH "master~2"



==TAG==


git tag [title] [SHA1-1]  = create a "lightweight tag" which points to a certain commit (specified by its SHA-1).  Cannot be signed.

git tag -a (or -s) -m "[msg]"  [tagname]  [SHA-1]   = create a tag object, which can be signed


==CHECKING OUT STUFF==


git checkout -- [name of file]   = add or replace [file] from repo into working directory
git checkout [SHA-1]  = put this SHA-1 revision into your working directory
git checkout [SHA-1 of a tree, commit, or tag] [name of file]  = checkout file from certain tree
	[good to do "git log [filename]" first to find out which
	revision/commit]
git checkout [name-of-branch]  = checkout [name-of-branch] into working directory




==BRANCHING==

You should always create a branch before starting work on a feature. This way, the master will always be in a working state, and you’ll be able to work in isolation of other’s changes.

git branch [new-branch-name]   =  create new branch from master branch

git branch = list branches, including which is the current one

git checkout [branch name] = switch to that branch

git branch -d [branch]   = delete branch, ensuring all differences have been merged
git branch -D [branch]   = delete branch, no matter whether all differences have been merged

After merging, if you delete the branch, it's still available in the remaining branch's history.



==MERGING BRANCHES==

git merge [branch] = merge [branch] into your master branch

git merge <branch> --no-commit
  merge branch <branch> into the current branch, but do not autocommit the
  result; allows you to make further tweaks

git merge [branch] --no-commit --ff
	Do not generate a *merge commit* if the merge resolved as a fast-forward, only update the branch pointer. This is the default behavior of git-merge.

git merge [branch] --no-commit --no-ff
	Generate a merge commit even if the merge resolved as a fast-forward.


git reset --hard HEAD = Undoing a merge. If you get stuck and decide to just give up and throw the whole mess away, you can always return to the pre-merge state with

$ git reset --hard ORIG_HEAD = Or, if you've already committed the merge that you want to throw away.

git cherry-pick rev = Aside from merging, sometimes you want to just pick one commit from a different branch. To apply the changes in revision rev and commit them to the current branch use cherry-pick.

A merge that is a "fast-forward" merge will not show a merge in the history (there will be no 2-parent commit).  It will just appear that all work was done on the destination branch. 



==RESETTING==


git reset = kill any changes since your last commit. Sets the current head to now become a specified commit and optionally resets the index and working tree to match. This command is useful if you notice some small error in a recent commit (or set of commits) and want to redo that part without showing the undo in the history.  (If you want to undo a commit other than the latest on a branch, git-revert is your friend.)

       --mixed
           Resets the index but not the working tree (i.e., the changed files
           are preserved but not marked for commit) and reports what has not
           been updated. This is the default action.

       --soft
           Does not touch the index file nor the working tree at all, but
           requires them to be in a good order. This leaves all your changed
           files "Changes to be committed", as git-status would put it.

       --hard
           Matches the working tree and index to that of the tree being
           switched to. Any changes to tracked files in the working tree since
           <commit> are lost.

       --merge
           Resets the index to match the tree recorded by the named commit,
           and updates the files that are different between the named commit
           and the current commit in the working tree.


git reset = reset index to HEAD (and not the working tree)  --  recommended for when copying another person's repo, to make sure there are no staged-but-uncommmitted files.

git reset HEAD <file>  =  to unstage file from index
git reset HEAD  = unstage all files from index
git reset --hard HEAD^  = reset both repo branch and current working directory to the parent of HEAD  (lose changes in working directory and the later commits of the branch)

git reset --hard HEAD~3  = The last three commits (HEAD, HEAD^, and HEAD~2) were bad and            you do not want to ever see them again. Do not do this if you have already given these commits to somebody else. 


Haven't committed yet, but don't want to save the changes? You can throw them away:
git reset --hard


To "unstage" a file, aka remove it from the index:
git reset HEAD cake.txt



==MISC==

git blame <file>  --  to see who changed a file last, and when

git pull = does both "fetch" and "merge"



git repo is technically both the working dir and the .git dir, though often the repo's are distributed w/a blank working dir, a blank index, and just the .git directory


rsync -rL rsync://rsync.kernel.org/pub/scm/git.git .git
	...is the same idea as...
git clone rsync://rsync.kernel.org/pub/scm/git/git.git/ my-git-test

	(both require a "git checkout" after cd'ing into the new directory)
	(-rL = recursive & preserve links)
	(when using rsync, the HEAD is messed up.  Another person had the same trouble: http://lists.zerezo.com/git/msg675736.html)

This server is also setup for this to work:
	it clone git://git.kernel.org/pub/scm/git/git.git/ my-git-test


When bandwidth is an issue, people can download the latest version of your repository without downloading all the history, using "shallow checkouts."  Note that such a copy has limitations, see http://www.kernel.org/pub/software/scm/git/docs/git-clone.html , option --depth for details.

Example:

$ git clone --depth 1 git://git.sv.gnu.org/gnulib.git



git fsck
running without "--full" is usually cheap and assures the repository health reasonably well.


git gc
repacks the local repository and performs other housekeeping tasks


git count-objects



==WORKING WITH DELETED ITEMS==

git ls-files --deleted
git ls-files -d
    only shows files that are in STAGING but deleted from WORKING





Pull a file back that was deleted:

$ ls -l [filename]
ls: slosh.tac: No such file or directory
# oh no!

$ git log -n 1 -- [filename]
commit 8d4a1f1a94e4aa37c1cb9d329a140d08eec1b587

$ git checkout 8d4a1f^ [filename]

Note that this does not actually put the file back in revision control. You can then add it or just inspect it or whatever from that point.




If you did actually want to remove a file from history, git filter-branch is the hacksaw you’re looking for. Definitely read up on its manpage before using it, since it will literally rewrite your project’s commits. This actually is a great tool for some actions, and can do all sorts of stuff like totally removing an author’s commits to moving the project root folder around. The command to remove a file from all revisions is:

git filter-branch --index-filter 'git rm --cached <file>' HEAD

This action can definitely be useful when you need to blow out sensitive or confidential information that may have been placed in your repository.




---> Find all deleted files:

git log --summary
then search for "delete mode"


---> Restore the deleted file (that is, restore the file from the parent tree
of the commit that deleted the file) using this line:
git checkout [the SHA-1 of the commit the deleted the file]~1 [filename]

           --if the file has spaces, either use backslash to escape them or put the file in quotes
           --EITHER include the path to the file OR if you are in the directory where the file used to live then you don't need to  include the path (just the filename)

---> Completely remove the DELETED file from the repository history (useful
if accidentally committed a file that never was needed, or if you committed
large binary files that are no longer needed, or if committed something now
considered confidential, etc.)
	see above, and also this:


(from http://help.github.com/removing-sensitive-data/   //   see also: http://github.com/guides/completely-remove-a-file-from-all-revisions)


git filter-branch --index-filter 'git update-index --remove Rakefile' master


This command will run the entire history of the master branch and change any commit that involved the file Rakefile, and any commits afterwards.

Note that git filter-branch only works on one branch at a time, so you may need to perform the cleanup on other branches as well. This could be problematic if the branch has a complex merge history.

While git filter-branch rewrites the history for you, the objects will remain in your local repo until they’ve been dereferenced and garbage collected. If you are working in your main repo you might want to force these objects to be purged:
	git reflog expire --all
	git gc --aggressive --prune


If you have been pushing your repo updates to a remote repo, do:
	# git push --force --verbose --dry-run
	# git push --force

Be warned that force-pushing does not erase commits on the remote repo, it simply introduces new ones and moves the branch pointer to point to them. If you are worried about users accessing the bad commits directly via SHA1, you will have to delete the repo and recreate it. 

BUT CHECK TO SEE IF THIS LAST PARAGRAPH IS ACCURATE (if not, notify GitHub) because the Git man page says this about '--force':
     "This can cause the remote repository to lose commits; use it with care"
           





==HOWTO===

Forgot something in your last commit? That's easy to fix.
    git reset --soft HEAD^
    Add that stuff you forgot:
    git add forgot.txt these.txt
    Then write over the last commit:
    git commit





==REBASING==

Think of it as:

    * Find all your (committed) changes, since you branched
    * Reset your branch, so that it's an exact copy of the current master
    * Re-apply all your changes again


Or put another way:

    * Suck in all (committed) changes to master made since I branched


git checkout branch_name
git rebase master

# If conflicts occur, and sooner or later they will,
# manually edit the conflicting files
git add file(s)
git rebase --continue




Reworking commit history

You want:

    * Two different commits to be combined into a single commit
    * Remove a commit entirely from the history
    * Change the commit message
    * Change the order that commits appear in the history
    * Split one big commit into multiple smaller commits

git rebase --interactive COMMIT_ID

COMMIT_ID should be the one BEFORE you want to fiddle with.


To combine revision 3 and 4 into a single revision, you can use git rebase. If you want to remove the changes in revision 3, you need to use the edit command in the interactive rebase mode. If you want to combine the changes into a single revision, use squash.

git rebase --abort
	//  kills the rebase process




==ORIGINAL INSTRUCTIONS FOR GITHUB==
	(the items below come from the GitHub repo-creation page)



Global setup:

  Download and install Git
  git config --global user.name "Your Name"
  git config --global user.email write2david@gmail.com
  Add your public key
        


Example steps:

  mkdir screendoor
  cd screendoor
  git init
  touch README
  git add README
  git commit -m 'first commit'
  git remote add origin git@github.com:write2david/screendoor.git
  git push origin master



======YET TO ORGANIZE=======

git config --global user.name "Rupert Monkey"
git config --global user.email rupert@example.com



For a list of the available tags for a given project:

git tag -l



git pull --rebase
When you pull, you will notice a summary of the changes transferred (updated/new branches and tags) and a diffstat of the changes applied to your working copy. If you have local commits then the --rebase option will ensure that your local commits will first be removed temporarily, then the new changes from the remote git repository are fetched and applied, after which your local commits are reapplied on top of the new changes. If you do not use --rebase and you have local commits, your local commits will be merged with the new changes introducing a new commit which is often undesired.



git push --dry-run
git push


If you do not pull before pushing, and changes have occurred that you never pulled, you may receive an error when you try to push. So, it is always best to pull before you push.

Git, by default, pushes all the local branches which exist also in the remote repository.



Committing on behalf of a contributor:  When committing code on behalf of others use the --author option, e.g.:
	git commit -a --author "Joe Coder <joe@coder.org>"



Undo Changes:
	Undo anything you put in the index:  git reset HEAD
	Undo anything in the workind directory:   git checkout HEAD



Alias commands: You can define new git commands using the alias configuration. For example, to define "git up" do:
	git config --global alias.up "pull --rebase"



Rewriting history
	 Say, you spend an evening implementing a feature. The session may generate 10 commits. After you are done, you see that some of the previous commits were buggy and the newer commits fix bugs introduced by them. Those commits would look better if they didn't have the bug to begin with. Or you may want to reorder commits to group them more logically by what they do. Or you may just want to improve the commit messages before making the changes public

The interactive rebase command is your friend. If you want to edit / reorder / squash-into-one the last five commits, do:

git rebase -i HEAD~5


That will bring up an editor page with the last five commits listed. You can reorder the lines to reorder the commits. Or change the word at the beginning of the line to get a chance to edit the commit, or squash it (ie. merge it) into the commit before it.

git format-patch



If you are the one that gets sent a 'patch', then you can apply the commit in the patch with the following command:
	git am [patch]



git-clone --depth 2 [source repo] [destination directory]

git-archive


"HEAD" always refers the current section to the current branch.
    For example:
    $ git checkout 0a633bf5
    # Git returns this:
    "HEAD is now at 0a633bf... [commit message]"



the ~ suffix which refers to the parent of a commit, or if followed by a number, to the Nth parent. For example, since "HEAD" refers to the most recent commit in the current branch, "HEAD~", refers to the previous commit, and "HEAD~2" refers to two commits back in the history.


http://ftp.newartisans.com/pub/git.from.bottom.up.pdf




git add --patch [file]

    -- go through each difference in the file and decide whether to include that difference in this commit
    -- good for one file contains two (or more) types of highly unrelated edits, appropriate for separating into two (or more) commits, possibly including other on-topic edited files in each of those commits.


git add --patch is actually a shortcut to features in git add --interactive



git commit --amend takes the changes staged in the index and squashes them into the previous commit. This lets you fix a problem with the last commit



People seem to get a lot of utility out of git-stash(1), which lets you move changes from your working copy into a lightweight holding area to be reintroduced some time later.
    Or, just create a new-topic branch.



Let's pretend you want to rework your last 10 patches, you'll run:

   $ git rebase -i HEAD~1


Then you can rewrite "pick" into "edit" if you want to change something in a commit, or "squash" if you want to merge it with the one from the line before.
    What the small help doesn't say is that you can actually reorder  your commits, and it will do what you expect it to do.
    Each time one change needs you to edit anything because either you asked for it, or that one of the change you asked for generated a conflict, then as usual the rebase will stop. You will be prompted to make the change, or fix the conflict, or merge comments (in case of a squash), and when all is in order, you just need to:

   $ git rebase --continue
   
   

git export

git checkout-index

http://the-gay-bar.com/2009/02/10/git-tricks-commiting-only-certain-changes-from-one-file/


git status -s

git log --oneline

git log --graph

git log --oneline --graph --decorate


git describe HEAD

git describe [SHA-1]

git bundle

git describe

git branch --contains [SHA-1]  (show which branch contains that SHA-1)


git status -sb

for commenting on a commit without changing the SHA:
    git notes edit [SHA-1]


git config --global help.autocorrect 1
    (suggest fixes for typo's in your git commands)